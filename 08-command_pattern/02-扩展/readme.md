你这个问题问得非常好！我们已经学习了命令模式的核心实现，但就像其他设计模式一样，它也有一些更高级的应用和变体，这些能帮助你写出更健壮、更灵活的代码。

-----

### 1\. 可撤销的命令 (Undoable Commands)

这是命令模式最经典的扩展之一。如果你的程序需要支持“撤销”操作，命令模式是实现它的完美选择。

**核心思想**：
为命令接口添加一个 `undo()` 方法，用于撤销 `execute()` 方法所执行的操作。每个具体命令都必须实现这两个方法。请求者（通常是一个历史管理器）会维护一个命令栈。每当执行一个新命令时，就将其压入栈中；当需要撤销时，就从栈中弹出一个命令并调用其 `undo()` 方法。

**算法应用**：

  * **数据预处理流水线**：在数据预处理过程中，你可能会对数据进行多次操作（如标准化、特征选择）。你可以将每个操作封装为一个可撤销的命令，如果发现某个步骤有问题，可以轻松地撤销到之前的状态。
  * **超参数搜索**：如果你在进行手动超参数调优，可以将每次修改参数的行为封装为命令。如果某次调整导致模型性能下降，你可以一键撤销到上一个参数配置。

**代码示例**：

```python
# 抽象命令接口
class Task(ABC):
    @abstractmethod
    def execute(self):
        pass

    @abstractmethod
    def undo(self):
        pass

# 可撤销的命令：改变学习率
class ChangeLearningRateCommand(Task):
    def __init__(self, model, new_lr):
        self._model = model
        self._new_lr = new_lr
        self._old_lr = model.learning_rate # 存储旧状态

    def execute(self):
        print(f"执行命令：学习率从 {self._old_lr} 改变为 {self._new_lr}")
        self._model.learning_rate = self._new_lr

    def undo(self):
        print(f"撤销命令：学习率从 {self._new_lr} 恢复为 {self._old_lr}")
        self._model.learning_rate = self._old_lr
```

-----

### 2\. 宏命令 (Macro Command)

**宏命令**是一种特殊的命令，它由一个或多个其他命令组成。这使得你可以将一系列简单的操作组合成一个复杂的、可复用的操作。

**核心思想**：
宏命令也是一个具体的命令类，但它的 `execute()` 方法会遍历其内部的命令列表，并依次调用每个命令的 `execute()` 方法。

**算法应用**：

  * **复杂的机器学习流水线**：你可以将一个完整的训练流水线（包括数据加载、特征工程、模型训练和评估）封装为一个宏命令。这样，你的客户端代码只需创建一个宏命令并执行它，即可启动整个流水线。
  * **批量任务处理**：如果你需要对多个模型执行相同的操作（如重新训练、导出），你可以创建一个宏命令，将每个模型的训练任务作为子命令添加进去，然后一次性执行。

**代码示例**：

```python
# 宏命令：一个由多个子命令组成的复杂任务
class TrainingPipelineMacroCommand(Task):
    def __init__(self):
        self._commands = []

    def add_command(self, command: Task):
        self._commands.append(command)

    def execute(self):
        print("--- 正在执行训练流水线宏命令 ---")
        for command in self._commands:
            command.execute()
        print("--- 训练流水线执行完毕 ---")
```

-----

### 3\. 命令模式与队列的结合

我们之前的例子已经初步展示了这一点，但这个组合在异步编程和并发处理中尤为重要。

**核心思想**：
生产者-消费者模式与命令模式的结合。生产者（如前端界面或调度器）创建命令对象并将其放入一个共享队列中。消费者（如一个或多个工作线程）从队列中取出命令并执行。

**算法应用**：

  * **异步模型训练**：用户在 Web 界面上提交一个模型训练任务后，服务器会创建一个 `TrainModelCommand` 对象并将其放入一个任务队列。后台的多个工作进程会从队列中取出任务并执行，而不会阻塞主线程。
  * **分布式计算**：在分布式机器学习中，你可以用命令模式来调度不同机器上的任务。例如，一个主节点可以创建数据分片、模型参数更新等命令，并将它们发送给不同的工作节点去执行。

通过深入研究这些知识点，你将能够更灵活地应用命令模式，并编写出更具健壮性和可扩展性的代码。这不仅能增强你的编程能力，也能让你在面试中展现出对设计模式更深层次的理解。
