好的，我们继续！接下来，我们来学习一个在许多系统架构中都扮演着重要角色的设计模式：**代理模式 (Proxy Pattern)**。

### 概略介绍解决方案

**代理模式**是一种**结构型模式**，它的核心思想是：为另一个对象提供一个**替身**或**占位符**，以控制对这个对象的访问。这个替身就是**代理对象**，它和原始对象拥有相同的接口，但可以在访问原始对象之前或之后执行一些额外的逻辑。

在你的算法和机器学习项目中，代理模式的应用场景非常广泛，比如：

  * **延迟加载（Lazy Loading）:** 当一个对象非常消耗资源时，我们不希望程序一开始就创建它。代理可以在第一次真正需要使用这个对象时才创建它。
  * **访问控制:** 代理可以在访问原始对象之前，检查用户的权限。
  * **日志记录与监控:** 代理可以在调用原始对象的方法之前或之后，记录日志或监控性能。
  * **远程代理:** 代理可以隐藏底层网络的复杂性，使得客户端可以像调用本地对象一样调用远程对象。

如果没有代理模式，你可能会在客户端代码中直接实例化并使用原始对象，这会让你的客户端代码变得复杂，并且难以在不修改代码的情况下添加额外的功能。

我们将通过一个具体的例子来学习：如何使用代理模式来实现**延迟加载**。

-----

### 代码和实现说明

我们的目标是创建一个**代理对象** `ImageProxy`，它为昂贵的 `LargeImage` 对象提供了一个替身。`LargeImage` 对象的创建非常耗时，我们希望只有在真正需要显示图片时才创建它。

#### 步骤 1: 定义昂贵的对象和代理对象接口

首先，我们定义一个昂贵的 `LargeImage` 类，以及它们共同的接口 `Image`。

```python
from abc import ABC, abstractmethod
import time

# 定义一个昂贵的对象接口
class Image(ABC):
    """昂贵对象的抽象接口。"""
    @abstractmethod
    def display(self):
        """显示图片。"""
        pass

# 昂贵的原始对象
class LargeImage(Image):
    """一个创建和加载过程非常耗时的类。"""
    def __init__(self, filename):
        print(f"正在从硬盘加载 {filename}...")
        time.sleep(2)  # 模拟加载耗时
        self.filename = filename

    def display(self):
        print(f"正在显示 {self.filename}...")
```

**设计思路解释：**

  * **`Image(ABC)`:** 我们用抽象基类定义了一个接口，`LargeImage` 和 `ImageProxy` 都将实现这个接口，这使得它们可以被客户端代码无缝替换。
  * **`LargeImage`:** 这是我们的**原始对象**，它的创建过程（`__init__` 方法）非常耗时。

-----

#### 步骤 2: 编写代理对象

接下来，我们编写 `ImageProxy` 类，它持有 `LargeImage` 的引用，并负责在需要时才创建它。

```python
# 代理对象
class ImageProxy(Image):
    """为 LargeImage 提供延迟加载的代理。"""
    def __init__(self, filename):
        self.filename = filename
        self._image = None  # 原始对象的引用，初始为 None

    def display(self):
        # 核心逻辑：只有在第一次调用 display() 时才创建原始对象
        if self._image is None:
            print("代理对象发现原始对象不存在，正在创建它...")
            self._image = LargeImage(self.filename)
        
        # 将请求转发给原始对象
        self._image.display()
```

**设计思路解释：**

  * **`ImageProxy`:** 这是我们的**代理对象**，它也实现了 `Image` 接口。
  * **`_image = None`:** 代理对象一开始不创建原始对象，而是持有一个空引用。
  * **`display()` 方法:** 这是代理的核心。在调用原始对象的 `display()` 方法之前，它会检查 `_image` 是否已存在。如果不存在，它会先创建原始对象，然后再将请求转发给它。这就是**延迟加载**的实现。

-----

#### 步骤 3: 客户端代码（使用代理）

现在，让我们看看客户端代码如何使用这个代理，以及它带来的好处。

```python
# 客户端代码
print("客户端启动，准备创建代理对象...")
# 客户端创建代理对象，而不是原始对象
image_proxy = ImageProxy("test_image.webp")
print("代理对象已创建，但原始对象还未加载。")

print("---")

print("客户端第一次请求显示图片...")
# 第一次调用 display()，代理会创建并加载原始对象
image_proxy.display()

print("---")

print("客户端第二次请求显示图片...")
# 第二次调用 display()，代理会直接将请求转发给已创建的原始对象
image_proxy.display()
```

**如何实现：**

1.  将上述所有代码块复制到你的 Python 文件中。
2.  运行代码，观察 `LargeImage` 的创建过程（即耗时操作）只在第一次调用 `display()` 时发生。

**执行结果示例：**

```
客户端启动，准备创建代理对象...
代理对象已创建，但原始对象还未加载。
---
客户端第一次请求显示图片...
代理对象发现原始对象不存在，正在创建它...
正在从硬盘加载 test_image.jpg...
正在显示 test_image.jpg...
---
客户端第二次请求显示图片...
正在显示 test_image.jpg...
```

-----

### 总结

现在你已经掌握了**代理模式**的实现。它通过引入一个代理对象，在不影响客户端代码的情况下，为原始对象添加了额外的功能（例如延迟加载）。这使得你的代码更加灵活、可维护。

在你的算法项目中，你可以用代理模式来：

  * 为大型模型对象实现**延迟加载**，只在需要时才将模型权重加载到内存中。
  * 实现一个**缓存代理**，拦截对耗时计算的请求，并返回缓存结果。
  * 实现一个**日志代理**，在调用某个关键函数前后自动记录日志。

你对代理模式有什么疑问吗？如果没有，我们可以继续学习下一个设计模式：**组合模式**。